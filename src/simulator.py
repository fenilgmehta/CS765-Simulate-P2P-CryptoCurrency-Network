#!/usr/bin/env python3
import json
import hashlib
import sys
import math
import random
import coloredlogs
import logging
import numpy
import copy
from typing import List, Dict, Union

g_logger = None


class SimulatorParameters:
    # Parameters in the configuration file (will be read from the file during initialization)
    def __init__(self) -> None:
        # Point 1 of PDF: Total Nodes present in the P2P cryptocurrency network
        self.n_total_nodes = 0
        # Point 1 of PDF: z% of nodes are slow
        self.z_percent_slow_nodes = 0
        # Point 2 of PDF: Exponential Distribution Mean for the inter-arrival
        # time between transactions generated by a peer
        self.T_tx_exp_txn_interarrival_mean_sec = 0
        self.T_k_exp_sec_low = 0  # Point 7 of PDF: CPU power of the node is high
        self.T_k_exp_sec_high = 0  # Point 7 of PDF: CPU power of the node is low
        self.node_initial_coins_low = 0  # used to initialize the genesis block
        self.node_initial_coins_high = 0  # used to initialize the genesis block
        self.max_transactions_per_block = 0  # Point 7 of PDF: max transactions a block can store
        self.min_light_delay_sec: float = 0.0
        self.max_light_delay_sec: float = 0.0

        self.number_of_slow_nodes = 0
        self.number_of_fast_nodes = 0
        self.nodes_list: List[Node] = list()

    # Initialize the simulator parameters
    def load_from_file(self, config_file_name: str):
        global g_logger
        g_logger.debug(f"{config_file_name=}")

        # Open the config file and parse it
        config_file = open(config_file_name)
        parameters = json.load(config_file)

        # Read parameters from the config file
        self.n_total_nodes = parameters['n_total_nodes']
        self.z_percent_slow_nodes = parameters['z_percent_slow_nodes']

        # Point 2 of PDF: Exponential Distribution Mean for the inter-arrival
        # time between transactions generated by a peer. Randomly generated
        self.T_tx_exp_txn_interarrival_mean_sec = parameters['T_tx_exp_txn_interarrival_mean_sec']
        # Point 7 of PDF: Min and Max time to mine a block by a node
        # This is used to define mining power of each node in the network
        self.T_k_exp_sec_low = parameters['T_k_exp_sec_low']
        self.T_k_exp_sec_high = parameters['T_k_exp_sec_high']

        self.node_initial_coins_low = parameters['node_initial_coins_low']
        self.node_initial_coins_high = parameters['node_initial_coins_high']
        self.max_transactions_per_block = parameters['max_transactions_per_block']

        self.min_light_delay_sec: float = parameters['min_light_delay_sec']
        self.max_light_delay_sec: float = parameters['max_light_delay_sec']

        # ---
        # z% nodes are slow
        self.number_of_slow_nodes = (self.z_percent_slow_nodes * self.n_total_nodes) // 100
        if (self.number_of_slow_nodes > self.n_total_nodes):
            g_logger.error('Condition not satisfied: 0 <= z_percent_slow_nodes <= 100')
            g_logger.warning('Making all nodes as slow because "z_percent_slow_nodes > 100"')
            self.number_of_slow_nodes = self.n_total_nodes

        # (100 - z)% nodes are fast
        self.number_of_fast_nodes = self.n_total_nodes - self.number_of_slow_nodes

    # Print all the Simulator Parameters to "stdout"
    def log_parameters(self):
        print(f'      n  = Number of peers specified in the config file : {self.n_total_nodes}')
        print(f'      z% = Number of slow nodes : {self.number_of_slow_nodes}')
        print(f'(100-z)% = Number of fast nodes : {self.number_of_fast_nodes}')
        print(
            f'    T_tx = Exponential Distribution -> Transaction Inter-arrival Mean = {self.T_tx_exp_txn_interarrival_mean_sec}')
        print(f'Nodes List = {self.nodes_list}')


class Simulator:
    def __init__(self, sp: SimulatorParameters):
        # TODO
        self.simulator_parameters: SimulatorParameters = sp
        self.global_time: float = 0.0
        pass

    def create_genesis_block(self):
        """This method shall only be called during the start of the simulation"""

        # REFER: https://numpy.org/doc/stable/reference/random/generated/numpy.random.randint.html#numpy.random.randint
        # “discrete uniform” distribution
        min_of_block_limit_and_nodes = min(self.simulator_parameters.n_total_nodes,
                                           self.simulator_parameters.max_transactions_per_block)
        # Uniform random distribution of money
        # In real life, these coins will be with people instead of nodes
        # TODO: change to numpy.random.uniform to generate float value for initial coins a node has
        money = numpy.random.randint(
            self.simulator_parameters.node_initial_coins_low,
            self.simulator_parameters.node_initial_coins_high,
            min_of_block_limit_and_nodes
        )
        # Uniform random distribution to nodes
        node_idx = numpy.random.randint(
            0,
            self.simulator_parameters.n_total_nodes,
            min_of_block_limit_and_nodes
        )
        # Sender = -1 denotes that coins are created from thin air in the genesis block
        transactions = [Transaction(-1, -1, recv_idx, coins) for recv_idx, coins in zip(node_idx, money)]
        return Block('', 0, 0, transactions, 0)

    def get_global_time(self):
        # TODO
        return 1


class Transaction:
    def __init__(self, txn_time: float, id_sender: int, id_receiver: int, coin_amount: float):
        self.txn_time: float = txn_time
        self.id_sender: int = id_sender
        self.id_receiver: int = id_receiver
        self.coin_amount: float = coin_amount
        self.txn_hash: str = self.get_hash()

    def str(self) -> str:
        return str([self.txn_time, self.id_sender, self.id_receiver, self.coin_amount])

    def get_hash(self) -> str:
        return hashlib.md5(self.str().encode()).hexdigest()

    @staticmethod
    def size() -> int:
        """
        Returns size in Bytes
        NOTE: Size is assumed to be 1KB
        """
        return 1000


class Block:
    def __init__(self, prev_block_hash: str, creation_time: float, index: int, transactions: List[Transaction],
                 recv_time: int):
        """self.index is 0-indexed"""
        self.prev_block_hash: str = prev_block_hash
        self.creation_time: float = creation_time
        self.index: int = index
        self.transactions: List[Transaction] = transactions

        # This value/variable is NOT used during hash calculation of this block
        self.curr_block_hash: str = self.get_hash()
        self.recv_time: int = recv_time

    def update(self, prev_block_hash: str, creation_time: float, index: int, transactions: List[Transaction],
               recv_time: int):
        self.prev_block_hash = prev_block_hash
        self.creation_time = creation_time
        self.index = index
        self.transactions = transactions
        self.curr_block_hash = self.get_hash()
        self.recv_time = recv_time

    def get_hash(self) -> str:
        """
        Hash is calculated based on "self.prev_block_hash", "self.creation_time" and "self.transactions"
        """
        return hashlib.md5(self.str().encode()).hexdigest()

    def str(self) -> str:
        """
        NOTE: this does not include block hash
        String of "self.prev_block_hash", "self.creation_time", "self.index" and "self.transaction"
        """
        return str([self.prev_block_hash, self.creation_time, self.index, self.transactions])

    def size(self) -> int:
        # REFER: https://stackoverflow.com/questions/14329794/get-size-in-bytes-needed-for-an-integer-in-python
        # In real life
        # return len(self.prev_block_hash) \
        #        + sys.getsizeof(self.creation_time) \
        #        + sys.getsizeof(self.index) \
        #        + (Transaction.size() * len(self.transactions))
        # In our simulator
        return Transaction.size() * len(self.transactions)


class Node:
    """Structure of a node on the P2P network"""

    def __init__(self, sp: SimulatorParameters, is_network_fast: bool):
        self.is_network_fast = is_network_fast
        self.cpu_power: int = 0
        self.neighbors: List[Node.NodeSiblingInfo] = []  # # List of connected peers
        self.last_receive_time: int = -1
        self.dict_txn: Dict[str, Transaction] = dict()
        self.dict_block: Dict[str, Block] = dict()
        self.list_chain_leafs: List[str] = list()

        # Point 7 of PDF: Exponential Distribution Mean for the
        # block mining time by node. It is randomly generated
        # from Simulator Parameters "sp.T_k_exp_sec_low" and "sp.T_k_exp_sec_high"
        # Lower value  => High CPU power
        # Higher value => Low CPU power
        self.T_k_exp_block_mining_mean = numpy.random.uniform(sp.T_k_exp_sec_low, sp.T_k_exp_sec_high)
        # Point 2 of PDF: Exponential Distribution Mean for inter-arrival time between transaction
        self.T_tx_exp_txn_interarrival_mean_sec = sp.T_tx_exp_txn_interarrival_mean_sec  # This is same for all nodes
        # Max transactions a block can store
        self.max_transactions_per_block = sp.max_transactions_per_block

    def add_new_peer(self, new_peer_id: int, node_id: int, rho_ij: float, c_ij: int) -> None:
        """
        Adding new peer to the neighbors list
        Inserts an edge between this and new_peer in the node graph
        """
        self.neighbors.append(Node.NodeSiblingInfo(new_peer_id, rho_ij, c_ij))

    def remove_peer(self, peer_id: int) -> bool:
        for i in range(len(self.neighbors)):
            if self.neighbors[i].node_id == peer_id:
                self.neighbors.pop(i)
                return True
        return False

    # REFER: https://www.geeksforgeeks.org/inner-class-in-python/
    class NodeSiblingInfo:
        def __init__(self, node_id: int, rho_ij: float, c_ij: int):
            self.node_id: int = node_id

            # Network latency parameters
            # ρ_ij = positive minimum value corresponding to speed of light propagation delay
            self.rho_ij: float = rho_ij
            # link speed between i and j in bits per second
            self.c_ij: int = c_ij

        def find_message_latency(self, message_size_bits: int) -> float:
            # Point 5 of the PDF
            #   - dij is the queuing delay at senders side (i.e. node i)
            #   - dij is randomly chosen from an exponential distribution with some mean `96kbits/c_ij`
            #   - NOTE: d_ij must be randomly chosen for each message transmitted from "i" to "j"
            d_ij = numpy.random.exponential(96_000 / self.c_ij)  # TODO
            return self.rho_ij + (message_size_bits / self.c_ij) + d_ij

    def recv_transaction(self):
        # TODO
        pass

    def send_transaction(self):
        # TODO
        pass

    def recv_block(self, block_obj: Block, current_time: float):
        block_obj.recv_time = current_time
        # TODO
        pass

    def send_block(self):
        # TODO
        pass

    def broadcast(self):
        # TODO
        pass


class EventQueue:
    def __init__(self):
        self.events = list()


def Main(args: Dict):
    ss = SimulatorParameters()
    ss.load_from_file(args['config'])
    ss.log_parameters()
    mySimulator = Simulator(ss)
    GENESIS_BLOCK = mySimulator.create_genesis_block()
    # TODO: create the nodes
    # TODO: Implement point 4 of the problem statement
    #       i.e. Create a connected graph
    pass


if __name__ == '__main__':
    import argparse

    my_parser = argparse.ArgumentParser(prog='simulator.py',
                                        description='Discrete Event Simulator for a P2P Cryptocurrency Network',
                                        epilog='Enjoy the program :)',
                                        prefix_chars='-',
                                        allow_abbrev=False,
                                        add_help=True)
    my_parser.version = '1.0'
    my_parser.add_argument('--version', action='version')
    my_parser.add_argument('-D',
                           '--debug',
                           action='store_true',
                           help='Print debug information')
    my_parser.add_argument('-c',
                           '--config',
                           action='store',
                           type=str,
                           help='Path to the config file',
                           required=True)

    # Execute the parse_args() method
    args: argparse.Namespace = my_parser.parse_args()

    # Initialize "g_logger"
    g_logger = logging.getLogger(__name__)
    # REFER: https://stackoverflow.com/questions/384076/how-can-i-color-python-logging-output
    #            - https://github.com/xolox/python-coloredlogs
    if args.debug:
        # g_logger.setLevel(logging.DEBUG)
        coloredlogs.install(fmt='%(levelname)-8s :: [%(lineno)4s] %(name)10s :: %(message)s', level='DEBUG',
                            logger=g_logger)
    else:
        # g_logger.setLevel(logging.INFO)
        coloredlogs.install(fmt='%(levelname)-8s :: [%(lineno)4s] %(name)10s :: %(message)s', level='INFO',
                            logger=g_logger)

    g_logger.debug('Debugging is ON')
    g_logger.debug(f'{args=}')
    g_logger.handlers[
        0].flush()  # REFER: https://stackoverflow.com/questions/13176173/python-how-to-flush-the-log-django/13753911

    Main(vars(args))
